% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/einsum.R
\name{einsum}
\alias{einsum}
\title{Einstein Summation}
\usage{
einsum(equation_string, ...)
}
\arguments{
\item{equation_string}{a string in Einstein notation where arrays
are separated by ',' and the result is separated by '->'. For
example \code{"ij,jk->ik"} corresponds to a standard matrix multiplication.
Whitespace inside the \code{equation_string} is ignored. Unlike the
equivalent functions in Python, \code{einsum()} only supports the explicit
mode. This means that the \code{equation_string} must contain '->'.}

\item{...}{the arrays that are combined. All arguments are converted
to arrays with \code{as.array}.}
}
\description{
\loadmathjax
Einstein summation is a convenient and concise notation for operations
on n-dimensional arrays.
}
\details{
The following table show, how the Einstein notation abbreviates complex
summation for arrays/matrices:

\tabular{lrr}{
  \code{equation_string} \tab Formula \tab \cr
  ------------------------\tab--------------------------------------\tab----------------------------------\cr
  \code{"ij,jk->ik"} \tab \mjseqn{ Y_{ik} = \sum_{j}{A_{ij} B_{jk}}  } \tab Matrix multiplication \cr
  \code{"ij->ji"}` \tab \mjseqn{ Y = A^{T}  } \tab Transpose \cr
  \code{"ii->i"} \tab \mjseqn{y = \text{diag}(A)} \tab Diagonal \cr
  \code{"ii->ii"} \tab \mjseqn{Y = \text{diag}(A) I} \tab Diagonal times Identity  \cr
  \code{"ii->"} \tab \mjseqn{y = \text{trace}(A) = \sum_i{A_{ii}} } \tab Trace \cr
  \code{"ijk,mjj->i"} \tab \mjseqn{ y_i = \sum_{j}\sum_{k}\sum_{m}A_{ijk}B_{mjj}  } \tab Complex 3D operation  \cr
}


The function and the conventions are inspired by the \code{einsum()} function
in NumPy (\href{https://numpy.org/doc/stable/reference/generated/numpy.einsum.html}{documentation}).
Unlike NumPy, 'einsum' only supports the explicit mode. The explicit mode is more flexible and
can avoid confusion. The common summary of the Einstein  summation to
"sum over duplicated indices" however is not a good mental model. A better rule of thumb is
"sum over all indices not in the result".

\emph{Note:} This function is implemented in pure R with a few for loops. Do not expect
impressive performance. However, if there is continued demand for a more performant
version, I would be open to implement it with Rcpp.
}
\examples{
mat1 <- matrix(rnorm(n = 4 * 8), nrow = 4, ncol = 8)
mat2 <- matrix(rnorm(n = 8 * 3), nrow = 8, ncol = 3)

# Matrix Multiply
mat1 \%*\% mat2
einsum("ij,jk -> ik", mat1, mat2)

# Diag
mat_sq <- matrix(rnorm(n = 4 * 4), nrow = 4, ncol = 4)
diag(mat_sq)
einsum("ii->i", mat_sq)
einsum("ii->ii", mat_sq)

# Trace
sum(diag(mat_sq))
einsum("ii->", mat_sq)


# Scalar product
mat3 <- matrix(rnorm(n = 4 * 8), nrow = 4, ncol = 8)
mat3 * mat1
einsum("ij,ij->ij", mat3, mat1)

# Transpose
t(mat1)
einsum("ij->ji", mat1)


# Batched L2 norm
arr1 <- array(c(mat1, mat3), dim = c(dim(mat1), 2))
c(sum(mat1^2), sum(mat3^2))
einsum("ijb,ijb->b", arr1, arr1)

}
